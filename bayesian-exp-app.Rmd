---
title: "Experimentation Tools | Bayesian A/B Test Analysis"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    css: styles.css
    vertical_layout: scroll
    logo: logo-sm.png
    favicon: favicon.png
    fig_height: 1
    navbar: 
      - { title: "Sequential App", href: "https://sdidev.shinyapps.io/sequential-test-calculator/" }
      - { title: "Sample Size", href: "https://sdidev.shinyapps.io/sample-size-calculator/" }
      - { title: "Runtime", href: "https://sdidev.shinyapps.io/sample-size-calculator-runtime/" }
      - { title: "Impact Simulation", href: "https://sdidev.shinyapps.io/test-result-simulator/" }
      - { title: "Experimentation ROI", "href:https://sdidev.shinyapps.io/experimentation-roi/" }
runtime: shiny
---

```{r to_do, include=FALSE}
# Deal with Bayes Factor vs Posterior distribution descriptions (CIs, ROPEs)
# Look at bayestestR https://easystats.github.io/bayestestR/articles/bayes_factors.html
# 
# Bayes Factor
# Bayes Factors (BFs) are indices of relative evidence of one ‚Äúmodel‚Äù over another.

# In their role as a hypothesis testing index, they are to Bayesian framework what a ùëù-value is to the classical/frequentist framework. In significance-based testing, ùëù-values are used to assess how unlikely are the observed data if the null hypothesis were true, while in the Bayesian model selection framework, Bayes factors assess evidence for different models, each model corresponding to a specific hypothesis.
# 
# MCMC Explanation - https://nbviewer.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter3_MCMC/Ch3_IntroMCMC_PyMC3.ipynb
# Start at current position.
# Propose moving to a new position (investigate a pebble near you).
# Accept/Reject the new position based on the position's adherence to the data and prior distributions (ask if the pebble likely came from the mountain).
# If you accept: Move to the new position. Return to Step 1.
# Else: Do not move to new position. Return to Step 1.
# After a large number of iterations, return all accepted positions.
# only the current position matters (new positions are investigated only near the current position). We can describe this property as memorylessness, i.e. the algorithm does not care how it arrived at its current position, only that it is there.
# 


```


```{r setup, include=FALSE}
library(ggplot2)
library(shiny)
library(gt)
library(tidyr)
library(dplyr)
library(scales)
library(capture)
library(shinyWidgets)
library(bayesAB)


# SDI colors are
# Light Orange: F58220
# Orange:FF6D00
# Dark Orange: E45C00
# Light Teal: 00A2B1
# Teal: 00747F
# Dark Teal: 004E54
# Dark Gray: 515151
# Light Gray: 9A9896

```

<script>
$('.navbar-logo').wrap('<a href="https://www.searchdiscovery.com/how-we-help/services/optimization/" target=_blank>');
</script>

```{r calculations_binomial, include=FALSE}
# Set a delay render around some inputs so that everything doesn't update repeatedly
ins_react_b <- debounce(reactive({
  c(
    input$cva,
    input$cvb, 
    input$traffa,
    input$traffb,
    input$prior_alpha,
    input$prior_beta
  )
  }),750)

# Declare reactive variables to hold all results for use throughout
rctRslts <- reactiveValues(pv = NULL, cl = NULL, upa = NULL, upb = NULL, upd = NULL, loa = NULL, lob = NULL, lod = NULL, diff = NULL, seDif = NULL, z = NULL, bt = NULL)

# Main event observer to listen for input changes and to calculate main results
# observeEvent(c(input$metric, ins_react_b(), input$confinterval, input$tails, input$nonf, input$bonf), {
observeEvent(ins_react_b(), {  
  # Don't execute unless traffic inputs are greater than conversion inputs
  # req(input$metric == "Binomial (Conversion Rate)")
  req(input$traffa > input$cva)
  req(input$traffb > input$cvb)
  req(input$cva > 0)
  req(input$cvb > 0)
  req(input$prior_alpha > 0)
  req(input$prior_beta > 0)
  
  ca <- input$cva
  cb <- input$cvb
  ta <- input$traffa
  tb <- input$traffb
  cvra <- ca/ta
  cvrb <- cb/tb
  reldiff <- cvrb/cvra-1
  SEa <- sqrt((cvra*(1-cvra))/ta)
  SEb <- sqrt((cvrb*(1-cvrb))/tb)
  SEdiff <- sqrt(SEa^2 + SEb^2)
  # ci <- input$confinterval/100
  ci <- .95
  ciZ <- abs(qnorm((1-ci)/2))
  cila <- cvra - SEa * ciZ
  ciua <- cvra + SEa * ciZ
  cilb <- cvrb - SEb * ciZ
  ciub <- cvrb + SEb * ciZ
  cild <- ((cvrb - cvra) - SEdiff * ciZ)/cvra
  ciud <- ((cvrb - cvra) + SEdiff * ciZ)/cvra
  z <- (cvrb - cvra) / SEdiff
  pval <- (1-pnorm(abs(z))) * 2 #input$tails
  pval <- p.adjust(pval, method = "bonferroni", n = 1) #input$bonf)
  conf <- 1-pval
  testpower <- power.prop.test(n = (input$traffa + input$traffb)/2, p1 = cvra, p2 = cvrb, sig.level = 1 - ci, alternative = "one") #ifelse(input$tails < 2, "one", "two"))

  
  # Test Analysis
  control_1 <- c(rep(0,input$traffa-input$cva),rep(1,input$cva))
  treatment_1 <- c(rep(0,input$traffb-input$cvb),rep(1,input$cvb))
  
  bayesianTest <- bayesTest(treatment_1, control_1, distribution = "bernoulli", priors = c("alpha" = input$prior_alpha, "beta" = input$prior_beta))
  # Code from: https://www.r-bloggers.com/2017/08/bayesian-ab-testing-made-easy/
  # http://127.0.0.1:21441/library/bayesAB/doc/introduction.html

  
  # Dump all the values into the reactive variables
  rctRslts$pv <- pval
  rctRslts$cl <- conf
  rctRslts$upa <- ciua
  rctRslts$upb <- ciub
  rctRslts$upd <- ciud
  rctRslts$loa <- cila
  rctRslts$lob <- cilb
  rctRslts$lod <- cild
  rctRslts$diff <- reldiff
  rctRslts$seDif <- SEdiff
  rctRslts$SEa <- SEa
  rctRslts$SEb <- SEb
  rctRslts$cvra <- cvra
  rctRslts$cvrb <- cvrb
  rctRslts$z <- z
  rctRslts$pwr <- testpower$power
  rctRslts$bt <- bayesianTest
}, ignoreInit = TRUE)
  
```

```{r chart_setup, include=FALSE}
rctTheme <- reactiveValues(
  main = list(
    theme_light() +
    theme(
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(),
      plot.title = element_blank(),
      axis.text.y = element_blank(), 
      legend.position = "none", 
      axis.ticks.y = element_blank()
      )
    )
)
```


Inputs {.sidebar data-width=270}
-----------------------------------------------------------------------
```{r metric_type}
# include = FALSE iskeeping this invisible for now
inputPanel(
    h4("Calculator Metric Setting"),
    awesomeRadio("metric", label = "Select your metric type",
      choices = c("Binomial (Conversion Rate)", "Continuous (Revenue)*"),
      selected = "Binomial (Conversion Rate)"),
  div(id = "metric_instr",
      "*For continuous metrics, you'll need to enter standard deviations calculated separately.")
)

```

```{r test_inputs}
# Primary test inputs
output$results_inputs <- renderUI({
  inputPanel(
        h4("Control Variation"),
        numericInput("cva", label = "Control Conversions", value = 890, min = 0),
        numericInput("traffa", label = "Control Traffic", value = 10000, min = 0),
      
        h4("Test Variation"),
        numericInput("cvb", label = "Test Conversions", value = 920, min = 0),
        numericInput("traffb", label = "Test Traffic", value = 10000, min = 0)
      )
})

uiOutput("results_inputs")
```

```{r config_inputs}

inputPanel(
  h4("Priors Inputs"),
  numericInput("prior_alpha", label = "Prior: beta distribution alpha value", value = 1, min = 1),
  numericInput("prior_beta", label = "Prior: beta distribution beta value", value = 1, min = 1) #,
  #numericInput("nonf", label = "Non-inferiority margin (if applicable)", value = 0, min = 0, max = 100),
  # numericInput("bonf", label = "Total p-values being calculated (applies Bonferroni correction)", value = 1, min = 1, max = 99)
)

```

```{r rev_inputs}
# observeEvent(input$metric,{
#   if (input$metric == "Binomial (Conversion Rate)") {
  # } else {
  #   lab_val <- "What's the $ value of raising your KPI by 1 for a single visit or visitor?"
  #   lab_vol <- "About how many visits or visitors per month would the tested change impact?"
  # }
  output$rev_inputs <- renderUI({
    lab_val <- "What's the approximate $ value of a conversion?"
    lab_vol <- "About how many conversions per month does the test audience provide?"
    lab_roi <- "How much revenue would this change need to generate within 6 months time in order to justify its cost?"
    
    inputPanel(
      h4("Revenue Projection Inputs"),
      numericInput("convValue", label = lab_val, value = 10, min = 0, max = 10000000),
      numericInput("convVolume", label = lab_vol, value = 1000, min = 1, max = 10000000),
      numericInput("testRoi", label = lab_roi, value = 10000, min = 0, max = 100000000)
    )
  })
# }, ignoreInit = TRUE)

uiOutput("rev_inputs")
```

```{r custom_inputs}

inputPanel(
  h4("Customize Test Details"),
  textInput("testname", label = "Name of test for report label", value = "A/B Test Results"),
  textInput("expA", label = "Label for Control Variation", value = "A"),
  textInput("expB", label = "Label for Test Variation", value = "B")#,
  
  # textInput("hypo", label = "Test hypothesis", value = "Test Hypothesis: If [this] then [that will happen] because [we have evidence]."),
  # fileInput("imgA", "Screenshot Control", accept = c('image/png', 'image/jpeg')),
  # fileInput("imgB", "Screenshot Test", accept = c('image/png', 'image/jpeg'))
  )

inputPanel(
  h4("Customize Colors"),
  textInput("hexa", label = "Custom hex color code for A", value = "#FF6D00"),
  textInput("hexb", label = "Custom hex color code for B", value = "#00A2B1"),
  textInput("hexd", label = "Custom hex color code for other charts", value = "#515151")
)

```

```{r pdf_export}
# EXPORT TO PDF
# Package from github: remotes::install_github("dreamRs/capture")
renderUI({
  div(id="exportpdf",
    capture::capture_pdf(
      # selector = ".level1",
      selector = ".print_area",
      filename = "abTestResults",
      icon("download"), "Export to PDF",
      margin = 2
    )
  )
})

```

<!-- Critical to set print area of pdf export. Ends after row with revenue chart -->
<div class="print_area"> 

Row {.topRow}
-----------------------------------------------------------------------

```{r resultsHeader}
output$testheader <- renderUI({
  div(
      div(
        h1(id = "testTitle", "Bayesian A/B Test Analysis (Beta release)")# paste0(input$testname))
      )
      # div(id = "hypothesis",
      #     p(paste0(input$hypo))),
      # div(id = "imagesboth", 
      #     div(id = "ssA",
      #         img(src = reactiveImages$imgA)
      #         ),
      #     div(id = "ssB",
      #         img(src = reactiveImages$imgB)
      #         )
      # )
  )
})


# observeEvent(input$imgA, {
#   req(is.null(input$imgA)==FALSE) 
# 
#   reactiveImages$imgA = base64enc::dataURI(file = input$imgA$datapath, mime = "image/png")
# 
# })
# 
# observeEvent(input$imgB, {
#   req(is.null(input$imgB)==FALSE) 
# 
#   reactiveImages$imgB = base64enc::dataURI(file = input$imgB$datapath, mime = "image/png")
#   
# })

uiOutput("testheader", class = "testmeta")
```

Row {data-height=350}
-----------------------------------------------------------------------
### Bayesian Test Summary
```{r}
#rmarkdown::render_delayed({
  render_gt({
    bayes_summary <- summary(rctRslts$bt, percentLift = 0, credInt = 0.95)
    prob_best_test <- paste0(round(as.numeric(bayes_summary$probability)*100,1),"%")
    expected_loss <- paste0(round(as.numeric(bayes_summary$posteriorExpectedLoss)/rctRslts$cvra*-100,2),"%")
    #expected_loss <- bayes_summary$posteriorExpectedLoss
    diff_conf_int <- bayes_summary$interval$Probability
    diff_conf_int <- paste0(round(diff_conf_int[1]*100,2),"% to ",round(diff_conf_int[2]*100,2),"%")
    bayes_table <- tibble(
      Stat = c("Probability Test is Better", "Expected Loss Choosing Test", "Confidence Interval"),
      Result = c(prob_best_test, expected_loss, diff_conf_int)
    )
    
    gt(bayes_table) #%>% 
      #fmt_percent(columns=vars(Result), rows=c("Probability Test is Better","Expected Loss"), decimals = 1)
  })
#})

# The Posterior Expected Loss (https://en.wikipedia.org/wiki/Bayes_estimator) is a good indicator of
# when to end a Bayesian AB test. If the PEL is lower than the absolute delta of the minimum effect
# you wish to detect, the test can be reasonably be stopped
```

### Posterior simulation of conversion rate difference
```{r prob_best}
rmarkdown::render_delayed({
  renderPlot({
    # Info haven't yet read on manipulatinggplot layers https://cran.r-project.org/web/packages/gginnards/vignettes/user-guide-2.html
    prob <- plot(rctRslts$bt,
         percentLift = -1,
         priors = FALSE,
         posteriors = FALSE)
    prob$samples$Probability +
      xlab("Difference in Conversion Rates") +
      ylab("Likelihood") +
      scale_fill_manual(values = c(input$hexb,input$hexa)) +
      #scale_discrete_manual(values = c("white","white"), aesthetics = c("color")) +
      #scale_alpha_manual(values = c(0.5,0.5)) +
      #scale_color_manual(values = c("white","white")) +
      #stat_bin(bins = 50) +
      #scale_x_continuous(labels = scales::percent) +
      scale_y_continuous(expand = c(0, 0)) +
      rctTheme$main
  })
})
```


Row {data-height=350}
-----------------------------------------------------------------------
### Prior Distribution (of Baseline)
```{r priors}
rmarkdown::render_delayed({
  renderPlot({
    plotBeta(input$prior_alpha, input$prior_beta) +
      xlab("Conversion Rate") +
      ylab("Likelihood") +
      rctTheme$main +
      scale_x_continuous(labels = scales::percent, expand = c(0,0)) 
  })
})

# Choosing priors correctly is very important. Please see http://fportman.com/writing/bayesab-0-dot7-0-plus-a-primer-on-priors/ for a detailed example of choosing priors within bayesAB. Here are
# some ways to leverage objective/diffuse (assigning equal probability to all values) priors:
```

### Posterior Distributions of Test & Control
```{r posteriors}
rmarkdown::render_delayed({
  renderPlot({
    posts <- plot(rctRslts$bt,
         percentLift = 0,
         priors = FALSE,
         samples = FALSE) 
    posts$posteriors$Probability +
      xlab("Conversion Rate") +
      ylab("Likelihood") +
      scale_fill_manual(values = c(input$hexb,input$hexa)) +
      scale_x_continuous(labels = scales::percent) +
      scale_y_continuous(expand = c(0, 0)) +
      rctTheme$main
    
  })
})
```

Row {data-height=350}
-----------------------------------------------------------------------

### Frequentist Results (for comparison)

```{r keyResults}
rmarkdown::render_delayed({
  renderUI({
    # Don't execute unless calculations have completed
    req(!is.null(rctRslts$diff))
 # Light Orange: F58220
# Orange:FF6D00
# Dark Orange: E45C00
# Light Teal: 00A2B1
# Teal: 00747F
# Dark Teal: 004E54
# Dark Gray: 515151
# Light Gray: 9A9896       
    # Get colors from inputs
    colora <- paste0("color:", "#FF6D00") # input$hexa)
    colorb <- paste0("color:", "#00747F") #  input$hexb)
    colord <- paste0("color:",ifelse(rctRslts$cvrb>rctRslts$cvra,"#00747F", "#FF6D00")) # input$hexb,input$hexa))
    
    # Set a few labels based on metric selection
#    if (input$metric == "Binomial (Conversion Rate)") {
      labs_results <- c(
        paste0(round(rctRslts$cvra*100,1),"%"),
        paste0(round(rctRslts$cvrb*100,1),"%")
      )
#    } else {
      # labs_results <- c(
      #   paste0(round(rctRslts$cvra,2)),
      #   paste0(round(rctRslts$cvrb,2))
      # )
#    }
    
    # Create UI elements in rows of divs
    div(id = "resultsContainer", # outer shell
      div(id = "resultsRow1", # row with variant names
        div(id = "resultsRow1Cell1", style = colora,
          input$expA
        ),
        div(id = "resultsRow1Cell2", style = colorb,
          input$expB
        )
        
      ),
      div(id = "resultsRow2", # row with conversion rates
        div(id = "resultsRow2Cell1",
          labs_results[1]
        ),
        div(id = "resultsRow2Cell2",
          labs_results[2]
        )
      ),
      div(id = "resultsRow3", style = colord, # row with conversion difference
          paste0(round(rctRslts$diff*100,1),"%")
      ),
      div(id = "resultsRow4", 
          "difference"
      ),
      div(id = "resultsRow5", # row with stat sig
        paste0(round(rctRslts$cl*100,1),"% statistical significance")
      ),
      div(id = "resultsRow6", # row with result determination
        if (rctRslts$cl*100 > 95) "This result is statistically significant. The test is conclusive." 
        # if (rctRslts$cl*100 > input$confinterval) "This result is statistically significant. The test is conclusive." 
        else "This result is not statistically significant. The test is inconclusive."
      )
    )
  })
})
```


### Frequentist Confidence Interval of Difference

```{r conf_interval_effect}
rmarkdown::render_delayed({
  renderPlot({
    # Don't execute unless calculations have completed
    req(!is.null(rctRslts$diff))
    
    sims <- 10000 # how many simulations of conversion rate for chart
    ptDiff <- rctRslts$cvrb - rctRslts$cvra # raw effect
    
    # simulate effect sizes with observed effect as mean and SEdiff as sd
    df <- data.frame(Effect = rnorm(n = sims, mean = ptDiff, sd = rctRslts$seDif)) %>%
      mutate(relEffect = Effect/rctRslts$cvra) # make simulated effects relative to control cvr
    
    ax_lab_x <- if_else(input$metric == "Binomial (Conversion Rate)", "True difference in conversion rates", "True difference in means")
    
    # plot the distribution
    ggplot(df, aes(x = relEffect)) +
      geom_density(aes(y=..scaled..), alpha = .2, bw = "SJ", adjust = 2, fill = input$hexd) +
      labs(x=ax_lab_x, y="Likelihood") +
      scale_x_continuous(labels = scales::percent) +
      scale_y_continuous(expand = c(0, 0), limits = c(0,1.2)) + # this fixes spacing around plot
      geom_vline(xintercept = c(rctRslts$lod,rctRslts$upd,rctRslts$diff), linetype = "dashed", size = .25) + #, color = input$hexd) +
      annotate(geom="text", x= c(rctRslts$lod,rctRslts$upd,rctRslts$diff),
         y=.5, 
         label= c( # line labels
           paste0(round(rctRslts$lod*100,1),"%"),
           paste0(round(rctRslts$upd*100,1),"%"),
           paste0(round(rctRslts$diff*100,1),"%")),
         fontface = "bold",
         angle = 90,
         size = 4.0) +
      theme_light() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()) # removes unnecessary elements
  })
})
```

Row {data-height=350}
-----------------------------------------------------------------------
### Frequentist Statistics
```{r table_stats}
render_gt({
  # Don't execute unless calculations have completed
  req(!is.null(rctRslts$diff))
  
  # Change some labels and formats based on metric type
  if (input$metric == "Binomial (Conversion Rate)") {
    metric_vars <- list(
      lab_a = "Conversion Rate A",
      lab_b = "Conversion Rate B",
      pct_r = c(1:3,10,11),
      num2_r = c(8),
      num4_r = c(4:7,9)
      )
  } else {
    metric_vars <- list(
      lab_a = "Mean A",
      lab_b = "Mean B",
      pct_r = c(3,10,11),
      num2_r = c(1,2,4,8),
      num4_r = c(5:7,9)
      )
  }
  
  # create data frame of all the pertinent data
  df <- data.frame(
    Metric = c(
      metric_vars$lab_a,
      metric_vars$lab_b,
      "Difference (B/A - 1)",
      "Difference (B - A)",
      "Standard Error A",
      "Standard Error B",
      "Standard Error Difference",
      "Z-score",
      "P-value",
      "Statistical Significance",
      "Power"
      ),
    Lower = c(
      rctRslts$loa,
      rctRslts$lob,
      rctRslts$lod,
      rctRslts$lod*rctRslts$cvra,
      NA,NA,NA,NA,NA,NA,NA
      ),
    Observed = c(
      rctRslts$cvra,
      rctRslts$cvrb,
      rctRslts$diff,
      rctRslts$diff*rctRslts$cvra,
      rctRslts$SEa,
      rctRslts$SEb,
      rctRslts$seDif,
      rctRslts$z,
      rctRslts$pv,
      rctRslts$cl,
      rctRslts$pwr
      ),
    Upper = c(
      rctRslts$upa,
      rctRslts$upb,
      rctRslts$upd,
      rctRslts$upd*rctRslts$cvra,
      NA,NA,NA,NA,NA,NA,NA
      )
  )
  
  # Put the data frame in a nice table format
  gt(df) %>%
    fmt_percent(columns=vars(Lower,Observed,Upper), rows=metric_vars$pct_r, decimals = 1) %>%
    fmt_number(columns=vars(Lower,Observed,Upper), rows=metric_vars$num2_r, decimals = 2) %>%
    fmt_number(columns=vars(Lower,Observed,Upper), rows=metric_vars$num4_r, decimals = 4) %>%
    cols_align(align = "left", columns = vars(Metric)) %>%
    cols_align(align = "center", columns = vars(Lower, Observed, Upper)) %>%
    cols_label(Metric = "Measure") %>%
    fmt_missing(columns=vars(Lower,Observed,Upper), rows = NULL, missing_text = " ") %>% # any NA values leave blanks
    tab_options(table.width = pct(100))

}, align = "center")
```

### Frequentist Confidence Intervals of Variants
```{r conf_intervals_means}
rmarkdown::render_delayed({
  renderPlot({
    # Don't execute unless calculations have completed
    req(!is.null(rctRslts$diff))
    
    sims <- 10000 # how many simulations of conversion rate for chart
    
    # Different labels and formats based on metric type selected
    if (input$metric == "Binomial (Conversion Rate)") {
      metric_vars <- list(
        lab_x = "True Conversion Rate",
        lab_annos = c(
           paste0(round(rctRslts$loa*100,1),"%"),
           paste0(round(rctRslts$lob*100,1),"%"),
           paste0(round(rctRslts$cvra*100,1),"%"),
           paste0(round(rctRslts$cvrb*100,1),"%"),
           paste0(round(rctRslts$upa*100,1),"%"),
           paste0(round(rctRslts$upb*100,1),"%")
         ),
        plot_scale_x = scale_x_continuous(labels = scales::percent)
        )
    } else {
      metric_vars <- list(
        lab_x = "True Mean",
        lab_annos = c(
           paste0(round(rctRslts$loa,2)),
           paste0(round(rctRslts$lob,2)),
           paste0(round(rctRslts$cvra,2)),
           paste0(round(rctRslts$cvrb,2)),
           paste0(round(rctRslts$upa,2)),
           paste0(round(rctRslts$upb,2))
         ),
        plot_scale_x = scale_x_continuous(labels = scales::label_comma())
        )
    }
    # create data frame of simulated conversion rates based on observed CVRs and standard errors
    df <- data.frame(
      variant = factor(c(rep("A", sims),rep("B", sims))),
      CVR = c(rnorm(n = sims, mean = rctRslts$cvra, sd = rctRslts$SEa), rnorm(n = sims, mean = rctRslts$cvrb, sd = rctRslts$SEb)))
  
    # plot the distributions
    # ggplot(df, aes(x = CVR)) +
    ci_plot <- ggplot(df, aes(x = CVR, fill = variant)) +
      # geom_density(aes(y=..scaled.., fill = variant), alpha = .5, bw = "SJ", adjust = 3) +
      geom_density(alpha = .5, bw = "SJ", adjust = 3)
    
    y_top <- ggplot_build(ci_plot)$layout$panel_scales_y[[1]]$range$range[[2]]
    
    ci_plot +
      scale_fill_manual(values = c(input$hexa,input$hexb)) + # pull in colors from inputs
      labs(x=metric_vars$lab_x, y="Likelihood") +
      metric_vars$plot_scale_x +
      scale_y_continuous(expand = expansion(mult = c(0, .1))) + # this fixes spacing around plot
      # scale_y_continuous(expand = c(0, 0), limits = c(0,1.2)) + # this fixes spacing around plot
      geom_vline(
        xintercept = c(
          rctRslts$loa,
          rctRslts$upa,
          rctRslts$cvra,
          rctRslts$lob,
          rctRslts$upb,
          rctRslts$cvrb
        ),
        linetype = "dashed",
        size = .25,
        color = c(input$hexa, input$hexa,input$hexa, input$hexb,input$hexb,input$hexb) # colors lines with custom colors from inputs
      ) +
      annotate(geom="text", 
         x= c(rctRslts$loa,rctRslts$lob,rctRslts$cvra,rctRslts$cvrb,rctRslts$upa,rctRslts$upb), # adds line labels
         # y = c(.2,.5,.2,.5,.2,.5),
         y = rep(c(y_top * .2, y_top * .5),3),
         vjust = 0.5, 
         label= metric_vars$lab_annos,
         fontface = "bold",
         angle = 90,
         size = 4.0) +
      annotate(geom="text", # adds variant labels from inputs
         x= c(rctRslts$cvra,rctRslts$cvrb),
         y = y_top * 1.1,
         hjust = "center",
         label= c(input$expA,input$expB),
         fontface = "bold",
         size = 4.0) +
      annotate(geom="pointrange", # adds interval lines
               x = c(rctRslts$cvra,rctRslts$cvrb),
               y = c(y_top * .1, y_top * .4),
               xmin = c(rctRslts$loa,rctRslts$lob),
               xmax = c(rctRslts$upa,rctRslts$upb),
               #vjust = c(-3,-3.5),
               size = .75,
               shape = 18) +
      theme_light() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.text.y = element_blank(), legend.position = "none", axis.ticks.y = element_blank()) # gets rid of unnecessary elements
  })
})
```

</div> <!-- End of print area -->

Row {data-height=50}
-----------------------------------------------------------------------
version 0.1  
To see version history, report bugs and submit feature requests [click here](https://github.com/alphanumerritt/bayesian-exp-app/issues){target="_blank"}.

